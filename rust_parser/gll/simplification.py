# Copyright (C) 2020 Valentin Lorentz
#
# This file is part of python-rust-parser.
#
# python-rust-parser is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# python-rust-parser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with python-rust-parser.  If not, see <https://www.gnu.org/licenses/>.

"""Rewrites a GLL grammar before it's passed to the semantics generation to
be simpler.
The simplified grammar is *not* equivalent (the simplification is lossy) so
it should not be passed to the Tatsu parser generation.

The difference is that string literals matter for the Tatsu parser generation
(they must be matched by the generated parser), but are useless in the AST
generated by the semantics.
"""

from . import grammar


def simplify_tree(node: grammar.RuleNode) -> grammar.RuleNode:
    node = node.visit(simplify_tree)

    match node:
        case grammar.Empty():
            return node
        
        case grammar.StringLiteral(_):
            # simplifies leaves
            return grammar.Empty()

        case grammar.SymbolName(_):
            return node

        case grammar.LabeledNode(_, _):
            return node

        case grammar.CharacterRange(from_char, to_char):
            raise NotImplementedError("character ranges")

        case grammar.Concatenation([]):
            return grammar.Empty()

        case grammar.Concatenation([grammar.Empty()]):
            return grammar.Empty()

        case grammar.Concatenation([item]):
            return item

        case grammar.Alternation([]):
            raise NotImplementedError("empty alternation")

        case grammar.Alternation([item]):
            return item

        case grammar.Concatenation(items):
            # main actor of simplification propagation
            items = [item for item in items if item != grammar.Empty()]
            match items:
                case []:
                    return grammar.Empty()
                case [item]:
                    return item
                case _:
                    return grammar.Concatenation(items)

        case grammar.Alternation([item]):
            return item
        
        case grammar.Alternation(_):
            return node
        
        case grammar.Option(grammar.LabeledNode(name, item)):
            # Move the label higher up the tree, so it can be used in
            # concatenation field names.
            return grammar.LabeledNode(name, grammar.Option(item))

        case grammar.Option(_):
            # It's tempting to simplify grammar.Option(grammar.Empty()), but it would
            # actually lose information in the resulting AST, even though it's only
            # equivalent to a boolean.
            return node

        case grammar.Repeated(_, _, _, _):
            return node

        case _:
            # should be unreachable
            assert False, node


def simplify_grammar(g: grammar.Grammar) -> grammar.Grammar:
    return grammar.Grammar(
        name=g.name,
        rules={name: simplify_tree(rule) for (name, rule) in g.rules.items()}
    )
